<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue-element-admin学习之旅</title>
      <link href="/2019/10/18/vue-element-admin%E5%AD%A6%E4%B9%A0%E4%B9%8B/"/>
      <url>/2019/10/18/vue-element-admin%E5%AD%A6%E4%B9%A0%E4%B9%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.im/post/59097cd7a22b9d0065fb61d2#heading-11" target="_blank" rel="noopener">学习网址</a></p><h1 id="axios封装"><a href="#axios封装" class="headerlink" title="axios封装"></a>axios封装</h1><p>在vue-element-admin中，已经对axios进行了封装。其中下面的requset.js主要是使用axios.create创建一个实例，为这个实例设置基础路径，对请求和响应增设拦截器，进行统一的操作。</p><pre><code class="js">import axios from &#39;axios&#39;import { MessageBox, Message } from &#39;element-ui&#39;import store from &#39;@/store&#39;import { getToken } from &#39;@/utils/auth&#39;//@ alias 别名指向src目录 在config.js中设置// 创建axios实例const service = axios.create({  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url  // withCredentials: true, // send cookies when cross-domain requests  timeout: 5000 // request timeout})// request 拦截器service.interceptors.request.use(  config =&gt; {    //发送请求之前操作，若存在token则向头部添加x-token    if (store.getters.token) {      // let each request carry token      // [&#39;X-Token&#39;] is a custom headers key      // please modify it according to the actual situation      config.headers[&#39;X-Token&#39;] = getToken()    }    return config  },  error =&gt; {    // do something with request error    console.log(error) // for debug    return Promise.reject(error)  })// 响应拦截器service.interceptors.response.use(  /**   * If you want to get http information such as headers or status   * Please return  response =&gt; response  */  /**   * Determine the request status by custom code   * Here is just an example   * You can also judge the status by HTTP Status Code   */  response =&gt; {    const res = response.data    //根据返回码进行相应的处理    // if the custom code is not 20000, it is judged as an error.    if (res.code !== 20000) {      Message({        message: res.message || &#39;Error&#39;,        type: &#39;error&#39;,        duration: 5 * 1000      })      // 50008: Illegal token; 50012: Other clients logged in; 50014: Token expired;      if (res.code === 50008 || res.code === 50012 || res.code === 50014) {        // to re-login        MessageBox.confirm(&#39;You have been logged out, you can cancel to stay on this page, or log in again&#39;, &#39;Confirm logout&#39;, {          confirmButtonText: &#39;Re-Login&#39;,          cancelButtonText: &#39;Cancel&#39;,          type: &#39;warning&#39;        }).then(() =&gt; {          store.dispatch(&#39;user/resetToken&#39;).then(() =&gt; {            location.reload()          })        })      }      return Promise.reject(new Error(res.message || &#39;Error&#39;))    } else {      return res    }  },  error =&gt; {    console.log(&#39;err&#39; + error) // for debug    Message({      message: error.message,      type: &#39;error&#39;,      duration: 5 * 1000    })    return Promise.reject(error)  })export default service</code></pre><p>以这个实例为基础，在@/api 中添加配置，加入请求路径，请求方法，请求数据。</p><pre><code class="js">import request from &#39;@/utils/request&#39;export function fetchList(query) {  return request({    url: &#39;/article/list&#39;,    method: &#39;get&#39;,    params: query  })}</code></pre><p>这样只需要在对应的页面中调用该方法发起请求,然后写处理函数。</p><p>fetchList(query).then(res=&gt;{</p><p>})</p><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><h1 id="easy-mock"><a href="#easy-mock" class="headerlink" title="easy-mock"></a>easy-mock</h1>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue-element-admin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex</title>
      <link href="/2019/10/18/vuex/"/>
      <url>/2019/10/18/vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><p>建立store.js</p><pre><code class="vue">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store({  state: {    number:0,  },  mutations: {    ADD(state){      state.number++    },    SUB(state){      state.number--    }  },  actions: {  }})</code></pre><p>在main.js中,将状态从根组件“注入”到每一个子组件中</p><pre><code class="vue">new Vue({  render: h =&gt; h(App),  store}).$mount(&#39;#app&#39;)</code></pre><p>在子组件中可以通过$store.state.number进行调用</p><h2 id="state属性"><a href="#state属性" class="headerlink" title="state属性"></a>state属性</h2><p>类似与vue中data属性，用于存放属性，键值对。可以通过 mutations 和 actions 来改变state的值。使用this.$store.state.属性名称 来获取相应的值。</p><h2 id="getters属性"><a href="#getters属性" class="headerlink" title="getters属性"></a>getters属性</h2><p>getters我们类比到vue中，那么它应该是 computed了 我们在使用的时候要使用 this.$store.getters.属性名   。用法也和computed类似，它实际上是调用一个方法，然后获取到的数据是经过一系列处理后并且return回来的数据。</p><h2 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h2><p>类似与vue的methods。可以通过调用其中的函数来修改state的值。this.$store.commit(‘ADD’)来调用mutations中的方法。</p><h2 id="actions属性"><a href="#actions属性" class="headerlink" title="actions属性"></a>actions属性</h2><p>actions属性用法和mutations类似，但是actions我们是不可以修改state的 需要在actions通过commit来调用mutations来修改数据，那么action的意义何在呢？处理异步事件就要用action来做了呀。调用方法是，this.$store.dispatch(“action的名字”,参数)</p><p>actions 方法的第一个参数是context，类似与store实例，可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p><p>常用法，获取context中的commit方法，提交commit调用mutations来修改数据</p><pre><code class="js">actions: {  increment ({ commit }) {    commit(&#39;increment&#39;)  }}</code></pre><p>综合示例</p><pre><code>// store.jsimport Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)export default new Vuex.Store({  state: {    number:0,  },  mutations: {    ADD(state){       state.number++    },    SUB(state){      state.number--    },    ADDPARAM(state,param){      if (typeof param !== &#39;number&#39;){        param = 0      }      state.number = state.number + param    }   },  actions: {    ASYNCADD(context,param){  //这里我们传入context上下文，里面包含 commit, state ,getters 这三个属性都可以通过context来调用到并且触发内部方法      setTimeout(function(){        context.commit(&#39;ADDPARAM&#39;,param)      },1000)    }  },  getters:{    getNumber(state){   //getter的书写方法      return state.number + 100    }  }})</code></pre><pre><code>&lt;!-- children.vue --&gt;&lt;template&gt;  &lt;div class=&quot;children&quot;&gt;    &lt;h1&gt;This is an children page&lt;/h1&gt;    &lt;button @click=&quot;add&quot;&gt;      +    &lt;/button&gt;      {{$store.state.number}}      {{$store.getters.getNumber}}      &lt;button  @click=&quot;sub&quot;&gt;      -    &lt;/button&gt;    &lt;button @click=&quot;actAdd&quot;&gt;action&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default{    name: &#39;children&#39;,    methods: {      add() {</code></pre><h2 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h2><p>Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter</p><pre><code class="js">const moduleA = {  state: { ... },  mutations: { ... },  actions: { ... },  getters: { ... }}const moduleB = {  state: { ... },  mutations: { ... },  actions: { ... }}const store = new Vuex.Store({  modules: {    a: moduleA,    b: moduleB  }})</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6记录</title>
      <link href="/2019/10/16/es6%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/16/es6%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h2><p>获取传入对象的值的数组</p><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p>获取传入对象的键的数组</p><h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h2><p>获取传入对象的数组形式的键值对</p><pre><code class="javascript">const cars = {bmw:3, tesla:2, toyota:1}const keys = Object.keys(cars)const vals = Object.values(cars)const entries = Object.entries(cars)console.log(vals,keys)console.log(entries)</code></pre><p>[ 3, 2, 1 ]   [ ‘bmw’, ‘tesla’, ‘toyota’ ]<br>[ [ ‘bmw’, 3 ], [ ‘tesla’, 2 ], [ ‘toyota’, 1 ] ]</p><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p>es6开始，直接在参数行赋值默认参数</p><pre><code class="javascript">function test(a=50,b=100){    console.log(a,b)}test(5)</code></pre><p>5 100</p><h2 id="模板对象"><a href="#模板对象" class="headerlink" title="模板对象"></a>模板对象</h2><pre><code class="js">// OLDvar name = &#39;Your name is &#39; + first + &#39; &#39; + last + &#39;.&#39;;var url = &#39;http://localhost:3000/api/messages/&#39; + id;// ES6语法 `${NAME}` 不是引号哦 tab建上方var name = `Your name is ${first} ${last}. `;var url = `http://localhost:3000/api/messages/${id}`;</code></pre><h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><pre><code class="js">var roadPoem = `Then took the other, as just as fair,    And having perhaps the better claim    Though as for that the passing there    Had worn them really about the same,`;</code></pre><h2 id="结构赋值"><a href="#结构赋值" class="headerlink" title="结构赋值"></a>结构赋值</h2><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><p>要求接受属性名和解构对象的属性一一对应</p><pre><code class="js">let node = {    type: &quot;Identifier&quot;,    name: &quot;foo&quot;};let { type, name } = node;console.log(type); // &quot;Identifier&quot;console.log(name); // &quot;foo&quot;</code></pre><p>一定要用一对小括号包裹解构赋值语句，JS引擎将一对开放的花括号视为一个代码块。语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值过程</p><pre><code class="js">let node = {    type: &quot;Identifier&quot;,    name: &quot;foo&quot;},type = &quot;Literal&quot;,name = 5;// 使用解构来分配不同的值({ type, name } = node);console.log(type); // &quot;Identifier&quot;console.log(name); // &quot;foo&quot;</code></pre><p>可以为变量设置默认值，如果它可能不存在node中</p><pre><code class="js">let node = {    type: &quot;Identifier&quot;,    name: &quot;foo&quot;};let { type, name, value = true } = node;console.log(type); // &quot;Identifier&quot;console.log(name); // &quot;foo&quot;console.log(value); // true</code></pre><p>为非同名变量赋值</p><pre><code class="js">let node = {    type: &quot;Identifier&quot;,    name: &quot;foo&quot;};let { type: localType, name: localName } = node;console.log(localType); // &quot;Identifier&quot;console.log(localName); // &quot;foo&quot;</code></pre><p>为非同名变量设初始值</p><pre><code class="js">let node = {    type: &quot;Identifier&quot;};let { type: localType, name: localName = &quot;bar&quot; } = node;console.log(localType); // &quot;Identifier&quot;console.log(localName); // &quot;bar&quot;</code></pre><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><p>数组解构与对象解构略有不同，数组解构按照位置进行解构,和对象不同，数组解构赋值不需要加括号</p><pre><code class="js">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ],firstColor = &quot;black&quot;,secondColor = &quot;purple&quot;;[ firstColor, secondColor ] = colors;console.log(firstColor); // &quot;red&quot;console.log(secondColor); // &quot;green&quot;</code></pre><p>变量交换，无需第三变量</p><pre><code class="js">// 在 ES6 中互换值let a = 1,    b = 2;[ a, b ] = [ b, a ];console.log(a); // 2console.log(b); // 1</code></pre><p>设置默认值，同理</p><pre><code>let colors = [ &quot;red&quot; ];let [ firstColor, secondColor = &quot;green&quot; ] = colors;console.log(firstColor); // &quot;red&quot;console.log(secondColor); // &quot;green&quot;</code></pre><p>不定元素</p><pre><code class="js">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];let [ firstColor, ...restColors ] = colors;console.log(firstColor); // &quot;red&quot;console.log(restColors); // [ &#39;green&#39;, &#39;blue&#39; ]</code></pre><p>数组复制</p><pre><code class="js">// 在 ES6 中克隆数组let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];let [ ...clonedColors ] = colors;console.log(clonedColors); //&quot;[red,green,blue]&quot;</code></pre><h4 id="字符串同样可以解构"><a href="#字符串同样可以解构" class="headerlink" title="字符串同样可以解构"></a>字符串同样可以解构</h4><pre><code class="js">const [a, b, c, d, e] = &#39;hello&#39;;console.log(a);//&quot;h&quot;console.log(b);//&quot;e&quot;console.log(c);//&quot;l&quot;console.log(d);//&quot;l&quot;console.log(e);//&quot;o&quot;</code></pre><h4 id="字符串集合函数"><a href="#字符串集合函数" class="headerlink" title="字符串集合函数"></a>字符串集合函数</h4><p>查找字符串是否包含在另一个字符串中</p><ul><li>includes()：返回布尔值，表示是否找到了参数字符串。</li><li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><pre><code class="js">let s = &#39;Hello world!&#39;;console.log(s.startsWith(&#39;Hello&#39;)) // trueconsole.log(s.endsWith(&#39;!&#39;)) // trueconsole.log(s.includes(&#39;o&#39;)) // true// 这三个方法都支持第二个参数，表示开始搜索的位置。console.log(s.startsWith(&#39;world&#39;, 6)) // trueconsole.log(s.endsWith(&#39;d&#39;,11)) // trueconsole.log(s.includes(&#39;Hello&#39;, 6)) // false</code></pre><h4 id="repeat（）"><a href="#repeat（）" class="headerlink" title="repeat（）"></a>repeat（）</h4><p>返回一个新字符串，将一个字符串重复n次</p><pre><code class="js">console.log(&quot;abc&quot;.repeat(3))  //abcabcabc</code></pre><h4 id="空白填充"><a href="#空白填充" class="headerlink" title="空白填充"></a>空白填充</h4><p>padStart() 和  padEnd()</p><pre><code class="js">// 第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。console.log(&#39;x&#39;.padStart(5, &#39;ab&#39;)) // &#39;ababx&#39;console.log(&#39;x&#39;.padEnd(5, &#39;ab&#39;)) // &#39;xabab&#39;// 补全字符串过长时，不全完毕多余的会去除console.log(&#39;x&#39;.padStart(5, &#39;abbbbbbb&#39;)) // &#39;abbbx&#39;console.log(&#39;x&#39;.padEnd(5, &#39;abbbbbbbbb&#39;)) // &#39;xabbb&#39;</code></pre><h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p><a href="https://www.jianshu.com/p/82237a7ca6e5" target="_blank" rel="noopener">参考文章</a></p><p>“承诺将来会执行”的对象在JavaScript中称为Promise对象。</p><p>resolve()   表示成功执行，执行时表示执行成功。可以传递参数，会执行.then的回调函数，且可以接受传递的参数</p><p>reject 表示执行失败。同理与resolve（）。由.catch（）进行接受。</p><pre><code class="js">var promise = new Promise(function (resolve, reject) {    var a = 2    if (a== 0) {        resolve(a)    } else {        reject(&quot;233&quot;)    }})promise.then(function (value) {    console.log(value);}).catch(function (error) {    console.log(error);})//1 //2</code></pre><p>then，catch的返回都是一个新的promise，可以做为下一个then或者catch的参数，执行没有错误后面的then会接受上一个then的参数，执行错误会由下面第一个catch方法来接受</p><pre><code class="js">var promise = new Promise(function (resolve, reject) {    resolve()})promise.then(function (value) { // 抛出错误    console.log(1 / x)}).then(function () { // 此方法不会执行    console.log(&#39;This &quot;then&quot; method will not happend!&#39;)}).catch(function (error) { // 接受错误，并打印出错误    console.log(&#39;Have an error: &#39;,error)}).then(function () { // 此方法会执行    console.log(&#39;This &quot;then&quot; method  will happend!&#39;)})</code></pre><p>Promise.all() 和 Promise.race()</p><p>都接受promise对象的数组。</p><p>Promise.all()当这个数组里的所有Promise对象全部变为resolve的时候，该方法才resolve</p><p>Promise.race()只要其中一个Promise对象变为Resolved或者Rejected状态，该方法才resolve</p><h4 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h4><p><a href="https://www.jianshu.com/p/1e75bd387aa0" target="_blank" rel="noopener">参考文章</a></p><p>async/await是一个用同步思维解决异步问题的方案，等待awiat返回结果才会继续执行</p><p>async</p><ul><li><p>自动将常规函数转换成Promise，返回值也是一个Promise对象</p></li><li><p>只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数</p></li><li><p>异步函数内部可以使用await</p></li></ul><pre><code class="js">//async 返回promise对象可以用then去捕获async function doubleAndAdd(a,b) {  return a + b}doubleAndAdd(1,2).then(res=&gt;{console.log(res)})</code></pre><p>awiat</p><ul><li>await 后面如果是promise那么等待promise对象resolve的值做为返回结果</li><li>await后面如果不是promise那么同样会等待后面函数或者表达式执行完毕</li><li>await只能在async函数内部使用,用在普通函数里就会报错</li></ul><pre><code class="js">async function doubleAndAdd(a,b) {  a = await doubleAfterSec(a)  b = await doubleAfterSec(b)  return a + b}function doubleAfterSec(param) {  return new Promise( resolve =&gt;{    setTimeout(()=&gt; resolve(param*2) ,1000)  })}doubleAndAdd(1,2).then(console.log)</code></pre><p>Promise.all的使用,多个await命令不存在依赖关系，即后面的await不依赖前一个await的结果。使用promise.all只有当后面的两个promise对象都完成时，才会同时处理。使用promise.all相比单独的await命令运行更快。</p><pre><code class="js">async function doubleAndAdd(a,b) {  [a,b] = await Promise.all([doubleAfterSec(a), doubleAfterSec(b)]);  return a + b}</code></pre><p>异常处理</p><p>async返回的是promise对象，通过catch捕获里面的reject异常</p><pre><code class="js">function timeout(ms) {  return new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; { reject(&#39;error&#39;) }, ms);  //reject模拟出错，返回error  });}async function asyncPrint(ms) {  console.log(&#39;start&#39;);  await timeout(ms)  console.log(&#39;end&#39;);  //这句代码不会被执行了}asyncPrint(1000).catch(err =&gt; {  console.log(err); // 从这里捕捉到错误});</code></pre><p>在async内部使用try/catch来捕获异常</p><pre><code class="js">function timeout(ms) {  return new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; { reject(&#39;error&#39;) }, ms);  //reject模拟出错，返回error  });}async function asyncPrint(ms) {  try {    console.log(&#39;start&#39;);    await timeout(ms);  //这里返回了错误    console.log(&#39;end&#39;);  //所以这句代码不会被执行了  } catch (err) {    console.log(err); //这里捕捉到错误error  }}asyncPrint(1000);</code></pre><p>提前截住错误。在await出拦截错误。</p><pre><code class="js">function timeout(ms) {  return new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {      reject(&#39;error&#39;)    }, ms);  //reject模拟出错，返回error  });}async function asyncPrint(ms) {  console.log(&#39;start&#39;);  await timeout(ms).catch(err =&gt; {  // 注意要用catch    console.log(err)  })  console.log(&#39;end&#39;);  //这句代码会被执行}asyncPrint(1000);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> es6Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js小记录</title>
      <link href="/2019/10/16/js%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/10/16/js%E5%B0%8F%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="foreach方法遍历数组"><a href="#foreach方法遍历数组" class="headerlink" title="foreach方法遍历数组"></a>foreach方法遍历数组</h2><p>相对与for循环来遍历数组，更快捷的写法</p><pre><code class="javascript">let a = [1, 2, 3, 4, 5, 6, 7, 8, 9,&quot;151&quot; , 10]a.forEach((value, index ,self) =&gt; {     console.log(value,index,self) })</code></pre><p>结果为</p><p>1 0 [ 1, 2, 3, 4, 5, 6, 7, 8, 9, ‘151’, 10 ]<br>2 1 [ 1, 2, 3, 4, 5, 10, 7, 8, 9, ‘151’, 10 ]<br>3 2 [ 1, 2, 3, 4, 5, 10, 7, 8, 9, ‘151’, 10 ]<br>4 3 [ 1, 2, 3, 4, 5, 10, 7, 8, 9, ‘151’, 10 ]<br>5 4 [ 1, 2, 3, 4, 5, 10, 7, 8, 9, ‘151’, 10 ]<br>10 5 [ 1, 2, 3, 4, 5, 10, 7, 8, 9, ‘151’, 10 ]<br>7 6 [ 1, 2, 3, 4, 5, 10, 7, 8, 9, ‘151’, 10 ]<br>8 7 [ 1, 2, 3, 4, 5, 10, 7, 8, 9, ‘151’, 10 ]<br>9 8 [ 1, 2, 3, 4, 5, 10, 7, 8, 9, ‘151’, 10 ]<br>151 9 [ 1, 2, 3, 4, 5, 10, 7, 8, 9, ‘151’, 10 ]<br>10 10 [ 1, 2, 3, 4, 5, 10, 7, 8, 9, ‘151’, 10 ]</p><p>foreach方法</p><p>传入一个回调函数，回调函数参数为 值，序号，数组本身</p><ul><li><p>foreach方法没有返回值</p></li><li><p>foreach方法会忽略数组中undefine的值</p></li></ul><h2 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h2><p>与foreach方法类似</p><pre><code class="javascript">let a = [1, 2, 3, 4, 5, 6, 7, 8, 9, , 10]let b = a.map((value, index ,self) =&gt; {     return [value,index] })console.log(b)</code></pre><p>[ [ 1, 0 ],<br>  [ 2, 1 ],<br>  [ 3, 2 ],<br>  [ 4, 3 ],<br>  [ 5, 4 ],<br>  [ 6, 5 ],<br>  [ 7, 6 ],<br>  [ 8, 7 ],<br>  [ 9, 8 ],<br>  &lt;1 empty item&gt;,<br>  [ 10, 10 ] ]</p><p>不同的是map方法有返回值，map方法会遍历数组，return的结果最后会被组合成为一个新的数组返回。且map方法不会跳过空白值。</p><h2 id="for-in遍历数组"><a href="#for-in遍历数组" class="headerlink" title="for  in遍历数组"></a>for  in遍历数组</h2><p>主要用于对象，用于数组可能不是按数组内部顺序进行遍历，for in遍历数组的索引值。主要用于普通对象。</p><h2 id="for-of-遍历数组"><a href="#for-of-遍历数组" class="headerlink" title="for of 遍历数组"></a>for of 遍历数组</h2><p>相较于for in，for of遍历数组的值，相较于foreach，for of可以使用break，continue等。可应用maps，set，array等可迭代对象，以及类数组对象。但是一般对象无法使用。要想遍历所有对象，搭配object.keys（）来使用。</p><pre><code class="javascript">const iterable = [1,,8,454];for(let i of iterable){    console.log(i)}</code></pre><p>1<br>undefined<br>8<br>454</p><pre><code class="javascript">const iterable = new Map([[&#39;one&#39;, 1], [&#39;two&#39;, 2]]);for (const [key, value] of iterable) {  console.log(`Key: ${key} and Value: ${value}`);}</code></pre><p>Key: one and Value: 1<br>Key: two and Value: 2</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown</title>
      <link href="/2019/10/11/markdown/"/>
      <url>/2019/10/11/markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="markdown-标题"><a href="#markdown-标题" class="headerlink" title="markdown 标题"></a>markdown 标题</h2><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code>*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong></p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><pre><code>***---</code></pre><hr><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><pre><code>~~haha~~</code></pre><p><del>haha</del></p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><pre><code>&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><p><u>带下划线文本</u></p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><pre><code>创建脚注格式类似这样 [^RUNOOB]。[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！</code></pre><p>创建脚注格式类似这样 [^RUNOOB]。</p><p>[^RUNOOB]: 菜鸟教程 – 学的不仅是技术，更是梦想！！！</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><pre><code>无序列表  *或+或-均可* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><ul><li><p>第一项</p></li><li><p>第二项</p></li><li><p>第三项</p></li></ul><pre><code>有序列表 1. 第一项2. 第二项3. 第三项</code></pre><pre><code>列表嵌套  回车 删除当前行标识 打四个空格 1. xxxx 回车 二级列表1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><ol><li><p>第一项：</p><ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li><p>第二项: </p><ul><li><p>1</p></li><li><p>2</p><pre><code>1. xxxx   2. xxxx   3. </code></pre></li></ul></li></ol><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><pre><code>&gt; 区块引用&gt; 菜鸟教程&gt; 学的不仅是技术更是梦想</code></pre><blockquote><p>区块引用<br>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><pre><code>&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项</code></pre><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><pre><code>列表中用区块 区块前需要加四个空格* 第一项    &gt; 菜鸟教程    &gt; 学的不仅是技术更是梦想* 第二项</code></pre><ul><li>第一项<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li><li>第二项</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>`printf()` 函数</code></pre><p><code>printf()</code></p><pre><code>代码块​```javascript$(document).ready(function () {    alert(&#39;RUNOOB&#39;);});​```</code></pre><pre><code class="javascript">$(document).ready(function () {    alert(&#39;RUNOOB&#39;);});</code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre><code>这是一个链接 [菜鸟教程](https://www.runoob.com)</code></pre><p>这是一个链接 <a href="https://www.runoob.com" target="_blank" rel="noopener">菜鸟教程</a></p><pre><code>&lt;https://www.runoob.com&gt;</code></pre><p><a href="https://www.runoob.com" target="_blank" rel="noopener">https://www.runoob.com</a></p><pre><code>链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）  [1]: http://www.google.com/  [runoob]: http://www.runoob.com/</code></pre><p>链接也可以用变量来代替，文档末尾附带变量地址：<br>这个链接用 1 作为网址变量 <a href="http://www.google.com/" target="_blank" rel="noopener">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/" target="_blank" rel="noopener">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code>![手动](http://static.runoob.com/images/runoob-logo.png)</code></pre><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="手动"></p><pre><code>markdown 无法指定图片大小&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;</code></pre><img src="http://static.runoob.com/images/runoob-logo.png" width="50%"><h2 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h2><p>Markdown 制作表格使用 <strong>|</strong> 来分隔不同的单元格，使用 <strong>-</strong> 来分隔表头和其他行。</p><p>语法格式如下：</p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><pre><code>| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="一些html元素"><a href="#一些html元素" class="headerlink" title="一些html元素"></a>一些html元素</h3><p><kbd> <b> <i> <em> <sup> <sub> <br></sub></sup></em></i></b></kbd></p><pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> </p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>通过添加反斜杠进行转义</p><pre><code>**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p><strong>文本加粗</strong><br>** 正常显示星号 **</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
